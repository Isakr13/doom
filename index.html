<html><head><base href=""><title>Doom-inspired Game with Procedural Levels</title><style>body{margin:0;overflow:hidden;background:#000;cursor:default}canvas{display:block}.hud{position:fixed;bottom:10px;left:10px;color:#f00;font-family:'Courier New',monospace;font-size:24px;text-shadow:2px 2px #000} ::-webkit-scrollbar { width: 8px; } ::-webkit-scrollbar-track { background: #222; border-radius: 4px; } ::-webkit-scrollbar-thumb { background: #f00; border-radius: 4px; } ::-webkit-scrollbar-thumb:hover { background: #ff3333; }.sortBtn:hover { background: #ff3333 !important; } .sortBtn.active { background: #f00 !important; }</style></head><body><canvas id="gameCanvas"></canvas><div class="hud" id="hudInfo"></div><audio id="gunSound" src="/Pistol Shot (Doom) - Sound Effect.mp3" preload="auto"></audio><audio id="shotgunSound" src="/Classic Doom Super Shotgun - Fire and Reload.mp3" preload="auto"></audio><audio id="bgMusic" src="/Facing The Spider.mp3" preload="auto" loop></audio><audio id="ripAndTearMusic" src="/Rip & Tear - Mick Gordon.mp3" preload="auto" loop></audio><script>(function(){const canvas=document.getElementById('gameCanvas');const gunSound = document.getElementById('gunSound');const shotgunSound = document.getElementById('shotgunSound');const bgMusic = document.getElementById('bgMusic');const ripAndTearMusic = document.getElementById('ripAndTearMusic');ripAndTearMusic.volume = 0.5;bgMusic.volume = 0.5;canvas.tabIndex=0;const context=canvas.getContext('2d');canvas.width=window.innerWidth;canvas.height=window.innerHeight;

    let startTime = Date.now();
    let score = 0;
    
    let map;
    let posX=1.5,posY=1.5;
    let dirX=1,dirY=0;
    let planeX=0,planeY=0.66;
    const keys={};
    let isMouseLocked=false;
    let isShooting = false;
    let shootAnimationTime = 0;
    let lastShotTime = 0; // For shot cooldown
    let level = 1;
    
    // Player stats
    let playerHealth = 100;
    let playerAmmo = 50;
    const maxAmmo = 100;
    const maxHealth = 100;
    const shootCooldown = 450; // 450ms cooldown between shots
    let playerWeapons = ['pistol'];
    let currentWeapon = 'pistol';
    let hasShotgun = false;
    let shotgunAmmo = 0;
    const maxShotgunAmmo = 50;
    
    // Reload animation variables
    let isReloading = false;
    let reloadProgress = 0;
    
    // Monster classes
    class Monster {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.health = 100;
            this.lastShootTime = 0;
            this.shootCooldown = 2000; // 2 seconds between shots
            this.speed = 0.015; // Slightly reduced speed
            this.type = 'normal';
        }
    
        update(playerX, playerY) {
            const currentTime = Date.now();
    
            // Check if player is visible before moving or shooting
            const dx = playerX - this.x;
            const dy = playerY - this.y;
            const angle = Math.atan2(dy, dx);
            let rayX = this.x;
            let rayY = this.y;
            const rayStep = 0.1;
            let canSeePlayer = true;
    
            // Cast ray to check if player is visible
            while (Math.sqrt(Math.pow(rayX - this.x, 2) + Math.pow(rayY - this.y, 2)) <
                   Math.sqrt(dx * dx + dy * dy)) {
                rayX += Math.cos(angle) * rayStep;
                rayY += Math.sin(angle) * rayStep;
    
                if (map[Math.floor(rayY)][Math.floor(rayX)] > 0) {
                    canSeePlayer = false;
                    break;
                }
            }
    
            if (canSeePlayer) {
                const distance = Math.sqrt(dx * dx + dy * dy);
    
                if (distance > 0.5) {
                    // Calculate movement vector
                    const moveX = (dx / distance) * this.speed;
                    const moveY = (dy / distance) * this.speed;
    
                    // Try to move on X axis
                    if (map[Math.floor(this.y)][Math.floor(this.x + moveX)] === 0) {
                        this.x += moveX;
                    }
    
                    // Try to move on Y axis
                    if (map[Math.floor(this.y + moveY)][Math.floor(this.x)] === 0) {
                        this.y += moveY;
                    }
                }
    
                // Shooting logic
                if (distance < 5 && currentTime - this.lastShootTime >= this.shootCooldown) {
                    this.shoot(playerX, playerY);
                    this.lastShootTime = currentTime;
                }
            }
        }
    
        shoot(playerX, playerY) {
            const dx = playerX - this.x;
            const dy = playerY - this.y;
            const angle = Math.atan2(dy, dx);
            enemyProjectiles.push(new EnemyProjectile(this.x, this.y, angle));
        }
    }
    
    class FastMonster extends Monster {
        constructor(x, y) {
            super(x, y);
            this.health = 70;
            this.speed = 0.025;
            this.type = 'fast';
        }
    }
    
    class StrongMonster extends Monster {
        constructor(x, y) {
            super(x, y);
            this.health = 200;
            this.speed = 0.01;
            this.shootCooldown = 1500;
            this.type = 'strong';
        }
    }
    
    // Enemy Projectile class
    class EnemyProjectile {
        constructor(x, y, angle) {
            this.x = x;
            this.y = y;
            this.speed = 0.05;
            this.dx = Math.cos(angle) * this.speed;
            this.dy = Math.sin(angle) * this.speed;
            this.radius = 0.1;
        }
    
        update() {
            this.x += this.dx;
            this.y += this.dy;
    
            // Check collision with player
            const distToPlayer = Math.sqrt(Math.pow(this.x - posX, 2) + Math.pow(this.y - posY, 2));
            if (distToPlayer < 0.3) { // Player hit
                playerHealth -= 10;
                updateHUD();
                return false;
            }
    
            // Check collision with walls
            if (map[Math.floor(this.y)][Math.floor(this.x)] > 0) {
                return false;
            }
    
            return true;
        }
    }
    
    // Player Projectile class
    class PlayerProjectile {
        constructor(angle = null) {
            this.x = posX;
            this.y = posY;
            this.angle = angle || Math.atan2(dirY, dirX);
            this.speed = 0.2;
            this.dx = Math.cos(this.angle) * this.speed;
            this.dy = Math.sin(this.angle) * this.speed;
            this.radius = 0.05;
        }
    
        update() {
            this.x += this.dx;
            this.y += this.dy;
    
            // Check collision with walls
            if (map[Math.floor(this.y)][Math.floor(this.x)] > 0) {
                return false;
            }
    
            // Check collision with monsters
            for (let monster of monsters) {
                if (monster.health > 0) {
                    const distToMonster = Math.sqrt(Math.pow(this.x - monster.x, 2) + Math.pow(this.y - monster.y, 2));
                    if (distToMonster < 0.5) {
                        if (currentWeapon === 'shotgun') {
                            monster.health -= 50;
                        } else {
                            monster.health -= 50;
                        }
                        if (monster.health <= 0) {
                            score += monster.type === 'strong' ? 200 : 100; // More points for stronger monsters
                        }
                        return false;
                    }
                }
            }
    
            // Check collision with exit
            if (map[Math.floor(this.y)][Math.floor(this.x)] === 2) {
                // Hit the exit, do nothing
                return false;
            }
    
            return true;
        }
    }
    
    // Initialize monsters and projectiles
    let monsters = [];
    const enemyProjectiles = [];
    const playerProjectiles = [];
    
    // Arrays for pickups
    let ammoPickups = [];
    let healthPickups = [];
    
    function updateMonsters() {
        monsters.forEach(monster => {
            if (monster.health > 0) {
                monster.update(posX, posY);
            }
        });
    
        // Update enemy projectiles
        for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
            const isActive = enemyProjectiles[i].update();
            if (!isActive) {
                enemyProjectiles.splice(i, 1);
            }
        }
    
        // Update player projectiles
        for (let i = playerProjectiles.length - 1; i >= 0; i--) {
            const isActive = playerProjectiles[i].update();
            if (!isActive) {
                playerProjectiles.splice(i, 1);
            }
        }
    }
    
    function drawMonsters() {
        monsters.forEach(monster => {
            if (monster.health <= 0) return;
    
            // Calculate monster's position relative to player
            const dx = monster.x - posX;
            const dy = monster.y - posY;
            const distance = Math.sqrt(dx * dx + dy * dy);
    
            // Ray casting to check if monster is visible (not behind walls)
            const angle = Math.atan2(dy, dx);
            let rayX = posX;
            let rayY = posY;
            const rayStep = 0.05;
            let wallHit = false;
    
            // Cast ray from player to monster to check visibility
            while (Math.sqrt(Math.pow(rayX - posX, 2) + Math.pow(rayY - posY, 2)) < distance) {
                rayX += Math.cos(angle) * rayStep;
                rayY += Math.sin(angle) * rayStep;
    
                if (map[Math.floor(rayY)][Math.floor(rayX)] > 0) {
                    wallHit = true;
                    break;
                }
            }
    
            if (wallHit) return; // Don't draw monster if behind wall
    
            // Calculate angle between player's direction and monster
            const viewAngle = Math.atan2(dy, dx) - Math.atan2(dirY, dirX);
    
            // Transform angle to be between -π and π
            let normalizedAngle = viewAngle;
            while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;
            while (normalizedAngle >= Math.PI) normalizedAngle -= 2 * Math.PI;
    
            // Check if monster is in view (FOV is about 60 degrees = PI/3)
            if (Math.abs(normalizedAngle) < Math.PI / 3) {
                // Calculate screen position
                const screenX = (normalizedAngle / (Math.PI / 3) + 1) * canvas.width / 2;
    
                // Calculate monster size based on distance
                const size = Math.min(canvas.height / (distance * 2), canvas.height / 2);
    
                // Draw monster sprite (differently based on type)
                if (monster.type === 'normal') {
                    drawNormalMonster(screenX, size);
                } else if (monster.type === 'fast') {
                    drawFastMonster(screenX, size);
                } else if (monster.type === 'strong') {
                    drawStrongMonster(screenX, size);
                }
    
                // Health bar
                const healthBarWidth = size / 2;
                const healthBarHeight = size / 20;
                context.fillStyle = '#300';
                context.fillRect(screenX - healthBarWidth/2, canvas.height / 2 - size/1.5, healthBarWidth, healthBarHeight);
                context.fillStyle = '#f00';
                context.fillRect(screenX - healthBarWidth/2, canvas.height / 2 - size/1.5,
                               healthBarWidth * (monster.health / (monster.type === 'strong' ? 200 : 100)), healthBarHeight);
            }
        });
    }
    
    function drawNormalMonster(screenX, size) {
        // Existing monster drawing code
        // Monster body (more deformed)
        context.fillStyle = '#660000';
        context.beginPath();
        context.ellipse(screenX, canvas.height / 2, size / 3, size / 1.8, Math.sin(Date.now() / 200) * 0.2, 0, Math.PI * 2);
        context.fill();
    
        // Add grotesque details to body
        context.fillStyle = '#440000';
        for(let i = 0; i < 5; i++) {
            context.beginPath();
            context.arc(
                screenX + Math.cos(i * Math.PI * 0.4) * size / 4,
                canvas.height / 2 + Math.sin(i * Math.PI * 0.4) * size / 3,
                size / 10,
                0,
                Math.PI * 2
            );
            context.fill();
        }
    
        // Deformed head
        context.fillStyle = '#330000';
        context.beginPath();
        const headOffset = Math.sin(Date.now() / 300) * size / 20;
        context.arc(screenX + headOffset, canvas.height / 2 - size / 2.5, size / 4, 0, Math.PI * 2);
        context.fill();
    
        // Jagged teeth
        context.fillStyle = '#FFFF99';
        for(let i = 0; i < 6; i++) {
            context.beginPath();
            context.moveTo(screenX - size/6 + (i * size/15), canvas.height / 2 - size/3);
            context.lineTo(screenX - size/8 + (i * size/15), canvas.height / 2 - size/2.2);
            context.lineTo(screenX - size/10 + (i * size/15), canvas.height / 2 - size/3);
            context.fill();
        }
    
        // Glowing evil eyes
        const eyeSize = size / 12;
        const eyeGlow = context.createRadialGradient(
            screenX - size/8, canvas.height / 2 - size/2.3, 0,
            screenX - size/8, canvas.height / 2 - size/2.3, size/6
        );
        eyeGlow.addColorStop(0, '#FF0000');
        eyeGlow.addColorStop(0.5, '#AA0000');
        eyeGlow.addColorStop(1, 'transparent');
    
        context.fillStyle = eyeGlow;
        context.beginPath();
        context.arc(screenX - size/8, canvas.height / 2 - size/2.3, size/6, 0, Math.PI * 2);
        context.arc(screenX + size/8, canvas.height / 2 - size/2.3, size/6, 0, Math.PI * 2);
        context.fill();
    
        // Add pulsing effect to eyes
        const pulseSize = Math.sin(Date.now() / 100) * size/20;
        context.fillStyle = '#FF0000';
        context.beginPath();
        context.arc(screenX - size/8, canvas.height / 2 - size/2.3, eyeSize + pulseSize, 0, Math.PI * 2);
        context.arc(screenX + size/8, canvas.height / 2 - size/2.3, eyeSize + pulseSize, 0, Math.PI * 2);
        context.fill();
    
        // Add dripping blood effect
        context.strokeStyle = '#FF0000';
        context.lineWidth = 2;
        for(let i = 0; i < 3; i++) {
            const dripOffset = ((Date.now() / 200 + i * 100) % 1000) / 1000;
            context.beginPath();
            context.moveTo(screenX - size/4 + i * size/4, canvas.height / 2 - size/3);
            context.lineTo(screenX - size/4 + i * size/4, canvas.height / 2 - size/3 + size/2 * dripOffset);
            context.stroke();
        }
    }
    
    function drawFastMonster(screenX, size) {
        // Fast monster drawing code
        context.fillStyle = '#004400';
        context.beginPath();
        context.ellipse(screenX, canvas.height / 2, size / 3, size / 2, 0, 0, Math.PI * 2);
        context.fill();
    
        // Eyes
        context.fillStyle = '#00FF00';
        context.beginPath();
        context.arc(screenX - size/8, canvas.height / 2 - size / 4, size / 12, 0, Math.PI * 2);
        context.arc(screenX + size/8, canvas.height / 2 - size / 4, size / 12, 0, Math.PI * 2);
        context.fill();
    }
    
    function drawStrongMonster(screenX, size) {
        // Strong monster drawing code
        context.fillStyle = '#552200';
        context.beginPath();
        context.rect(screenX - size / 2, canvas.height / 2 - size / 2, size, size);
        context.fill();
    
        // Spikes
        context.fillStyle = '#FFFFFF';
        for (let i = 0; i < 5; i++) {
            context.beginPath();
            context.moveTo(screenX - size / 2 + (i * size / 5), canvas.height / 2 - size / 2);
            context.lineTo(screenX - size / 2 + ((i + 0.5) * size / 5), canvas.height / 2 - size / 1.5);
            context.lineTo(screenX - size / 2 + ((i + 1) * size / 5), canvas.height / 2 - size / 2);
            context.fill();
        }
    
        // Mouth
        context.fillStyle = '#990000';
        context.beginPath();
        context.arc(screenX, canvas.height / 2 + size / 4, size / 4, 0, Math.PI, false);
        context.fill();
    }
    
    function drawEnemyProjectiles() {
        enemyProjectiles.forEach(proj => {
            const dx = proj.x - posX;
            const dy = proj.y - posY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) - Math.atan2(dirY, dirX);
    
            let normalizedAngle = angle;
            while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;
            while (normalizedAngle >= Math.PI) normalizedAngle -= 2 * Math.PI;
    
            if (Math.abs(normalizedAngle) < Math.PI / 3) {
                const screenX = (normalizedAngle / (Math.PI / 3) + 1) * canvas.width / 2;
                const size = Math.min(20 / distance, 20);
    
                context.fillStyle = '#ff0000';
                context.beginPath();
                context.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
                context.fill();
            }
        });
    }
    
    function drawPlayerProjectiles() {
        playerProjectiles.forEach(proj => {
            const dx = proj.x - posX;
            const dy = proj.y - posY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) - Math.atan2(dirY, dirX);
    
            let normalizedAngle = angle;
            while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;
            while (normalizedAngle >= Math.PI) normalizedAngle -= 2 * Math.PI;
    
            if (Math.abs(normalizedAngle) < Math.PI / 3) {
                const screenX = (normalizedAngle / (Math.PI / 3) + 1) * canvas.width / 2;
                const size = Math.min(10 / distance, 10);
    
                context.fillStyle = '#ffff00';
                context.beginPath();
                context.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
                context.fill();
            }
        });
    }
    
    function drawPickups() {
        // Draw ammo pickups
        ammoPickups.forEach(pickup => {
            const dx = pickup.x - posX;
            const dy = pickup.y - posY;
            const distance = Math.sqrt(dx * dx + dy * dy);
    
            // Check if pickup is visible
            const angleToPickup = Math.atan2(dy, dx) - Math.atan2(dirY, dirX);
            let normalizedAngle = angleToPickup;
            while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;
            while (normalizedAngle >= Math.PI) normalizedAngle -= 2 * Math.PI;
            if (Math.abs(normalizedAngle) > (Math.PI / 3)) return;
    
            // Ray casting to check if pickup is visible
            const angle = Math.atan2(dy, dx);
            let rayX = posX;
            let rayY = posY;
            const rayStep = 0.05;
            let wallHit = false;
    
            while (Math.sqrt(Math.pow(rayX - posX, 2) + Math.pow(rayY - posY, 2)) < distance) {
                rayX += Math.cos(angle) * rayStep;
                rayY += Math.sin(angle) * rayStep;
    
                if (map[Math.floor(rayY)][Math.floor(rayX)] > 0) {
                    wallHit = true;
                    break;
                }
            }
    
            if (wallHit) return;
    
            const screenX = (normalizedAngle / (Math.PI / 3) + 1) * canvas.width / 2;
            const size = Math.min(80 / distance, 80);
            const groundOffset = canvas.height / 2 + size * 2;
    
            if (pickup.isShotgun) {
                // Shotgun model
                const baseSize = size * 1.2;
    
                // Main body
                context.fillStyle = '#8B4513';
                context.fillRect(
                    screenX - baseSize / 2,
                    groundOffset - baseSize/2,
                    baseSize,
                    baseSize/3
                );
    
                // Barrels
                context.fillStyle = '#333';
                context.fillRect(
                    screenX - baseSize / 4,
                    groundOffset - baseSize/2 - baseSize/4,
                    baseSize/2,
                    baseSize/2
                );
    
                // Glow effect
                const glow = context.createRadialGradient(
                    screenX,
                    groundOffset,
                    0,
                    screenX,
                    groundOffset,
                    baseSize
                );
                glow.addColorStop(0, 'rgba(255,136,0,0.3)');
                glow.addColorStop(1, 'rgba(255,136,0,0)');
                context.fillStyle = glow;
                context.fillRect(
                    screenX - baseSize,
                    groundOffset - baseSize,
                    baseSize*2,
                    baseSize*2
                );
            } else {
                // Ammo box
                context.fillStyle = '#FFFF00';
                context.fillRect(
                    screenX - size / 2,
                    groundOffset - size/2,
                    size,
                    size
                );
    
                const glow = context.createRadialGradient(
                    screenX,
                    groundOffset,
                    0,
                    screenX,
                    groundOffset,
                    size
                );
                glow.addColorStop(0, 'rgba(255,255,0,0.3)');
                glow.addColorStop(1, 'rgba(255,255,0,0)');
                context.fillStyle = glow;
                context.fillRect(
                    screenX - size,
                    groundOffset - size,
                    size*2,
                    size*2
                );
            }
        });
    
        // Draw health pickups
        healthPickups.forEach(pickup => {
            const dx = pickup.x - posX;
            const dy = pickup.y - posY;
            const distance = Math.sqrt(dx * dx + dy * dy);
    
            // Check if pickup is visible
            const angleToPickup = Math.atan2(dy, dx) - Math.atan2(dirY, dirX);
            let normalizedAngle = angleToPickup;
            while (normalizedAngle < -Math.PI) normalizedAngle += 2 * Math.PI;
            while (normalizedAngle >= Math.PI) normalizedAngle -= 2 * Math.PI;
            if (Math.abs(normalizedAngle) > (Math.PI / 3)) return;
    
            // Ray casting to check if pickup is visible
            const angle = Math.atan2(dy, dx);
            let rayX = posX;
            let rayY = posY;
            const rayStep = 0.05;
            let wallHit = false;
    
            while (Math.sqrt(Math.pow(rayX - posX, 2) + Math.pow(rayY - posY, 2)) < distance) {
                rayX += Math.cos(angle) * rayStep;
                rayY += Math.sin(angle) * rayStep;
    
                if (map[Math.floor(rayY)][Math.floor(rayX)] > 0) {
                    wallHit = true;
                    break;
                }
            }
    
            if (wallHit) return;
    
            const screenX = (normalizedAngle / (Math.PI / 3) + 1) * canvas.width / 2;
            const size = Math.min(80 / distance, 80);
            const groundOffset = canvas.height / 2 + size * 2;
    
            // Health pack
            context.fillStyle = '#FF0000';
            context.fillRect(
                screenX - size / 2,
                groundOffset - size/2,
                size,
                size
            );
    
            // Cross
            context.strokeStyle = '#FFFFFF';
            context.lineWidth = Math.max(2, size / 8);
            context.beginPath();
            context.moveTo(
                screenX - size / 3,
                groundOffset
            );
            context.lineTo(
                screenX + size / 3,
                groundOffset
            );
            context.moveTo(
                screenX,
                groundOffset - size/3
            );
            context.lineTo(
                screenX,
                groundOffset + size/3
            );
            context.stroke();
    
            const glow = context.createRadialGradient(
                screenX,
                groundOffset,
                0,
                screenX,
                groundOffset,
                size
            );
            glow.addColorStop(0, 'rgba(255,0,0,0.3)');
            glow.addColorStop(1, 'rgba(255,0,0,0)');
            context.fillStyle = glow;
            context.fillRect(
                screenX - size,
                groundOffset - size,
                size*2,
                size*2
            );
        });
    }
    
    function updateHUD() {
        const hudElement = document.getElementById('hudInfo');
        let ammoDisplay = currentWeapon === 'pistol' ? playerAmmo : shotgunAmmo;
        hudElement.innerHTML = `LEVEL: ${level} | HEALTH: ${playerHealth} | SCORE: ${score} | ${currentWeapon.toUpperCase()}: ${ammoDisplay}`;
        if (hasShotgun) {
            hudElement.innerHTML += ` | Press 1-2 to switch weapons`;
        }
    }
    
    canvas.addEventListener('click', () => {
        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
        canvas.requestPointerLock();
        canvas.focus();
    });
    
    canvas.addEventListener('mousedown', () => {
        const currentTime = Date.now();
        if (isMouseLocked && currentTime - lastShotTime >= shootCooldown && !isReloading) {
            if (currentWeapon === 'pistol' && playerAmmo > 0) {
                isShooting = true;
                shootAnimationTime = 10;
                playerAmmo--;
                lastShotTime = currentTime;
                gunSound.currentTime = 0;
                gunSound.play().catch(error => console.log("Audio play failed:", error));
                playerProjectiles.push(new PlayerProjectile());
            } else if (currentWeapon === 'shotgun' && shotgunAmmo > 0) {
                isShooting = true;
                isReloading = true;
                reloadProgress = 0;
                shootAnimationTime = 10;
                shotgunAmmo--;
                lastShotTime = currentTime + 200;
                shotgunSound.currentTime = 0;
                shotgunSound.play().catch(error => console.log("Audio play failed:", error));
                
                for (let i = -2; i <= 2; i++) {
                    const spread = i * 0.1;
                    const angle = Math.atan2(dirY, dirX) + spread;
                    playerProjectiles.push(new PlayerProjectile(angle));
                }
            }
            updateHUD();
        }
    });
    
    document.addEventListener('pointerlockchange',lockChangeAlert,false);
    document.addEventListener('mozpointerlockchange',lockChangeAlert,false);
    function lockChangeAlert() {
        if(document.pointerLockElement===canvas||document.mozPointerLockElement===canvas){
            document.addEventListener("mousemove",updatePosition,false);
            isMouseLocked=true;
        } else{
            document.removeEventListener("mousemove",updatePosition,false);
            isMouseLocked=false;
        }
    }
    function updatePosition(e){
        if(!isMouseLocked)return;
        const movementX=e.movementX||e.mozMovementX||0;
        const rotSpeed=movementX*0.002;
        const oldDirX=dirX;
        dirX=dirX*Math.cos(rotSpeed)-dirY*Math.sin(rotSpeed);
        dirY=oldDirX*Math.sin(rotSpeed)+dirY*Math.cos(rotSpeed);
        const oldPlaneX=planeX;
        planeX=planeX*Math.cos(rotSpeed)-planeY*Math.sin(rotSpeed);
        planeY=oldPlaneX*Math.sin(rotSpeed)+planeY*Math.cos(rotSpeed);
    }
    
    window.addEventListener('keydown',(e)=>{keys[e.key.toLowerCase()]=true;});
    window.addEventListener('keyup',(e)=>{keys[e.key.toLowerCase()]=false;});
    function movePlayer(){
        const moveSpeed=0.05;
        const buffer = 0.1; // Add a small buffer for smoother collision
    
        if(keys['w']){
            const newPosX = posX + dirX * moveSpeed;
            const newPosY = posY + dirY * moveSpeed;
            
            // Check both current and new positions
            if (map[Math.floor(posY)][Math.floor(newPosX)] === 0 ||
                map[Math.floor(posY)][Math.floor(newPosX)] === 2) {
                posX = newPosX;
            }
            if (map[Math.floor(newPosY)][Math.floor(posX)] === 0 ||
                map[Math.floor(newPosY)][Math.floor(posX)] === 2) {
                posY = newPosY;
            }
        }
        if(keys['s']){
            const newPosX = posX - dirX * moveSpeed;
            const newPosY = posY - dirY * moveSpeed;
            
            if (map[Math.floor(posY)][Math.floor(newPosX)] === 0 ||
                map[Math.floor(posY)][Math.floor(newPosX)] === 2) {
                posX = newPosX;
            }
            if (map[Math.floor(newPosY)][Math.floor(posX)] === 0 ||
                map[Math.floor(newPosY)][Math.floor(posX)] === 2) {
                posY = newPosY;
            }
        }
        if(keys['a']){
            const newPosX = posX - planeX * moveSpeed;
            const newPosY = posY - planeY * moveSpeed;
            
            if (map[Math.floor(posY)][Math.floor(newPosX)] === 0 ||
                map[Math.floor(posY)][Math.floor(newPosX)] === 2) {
                posX = newPosX;
            }
            if (map[Math.floor(newPosY)][Math.floor(posX)] === 0 ||
                map[Math.floor(newPosY)][Math.floor(posX)] === 2) {
                posY = newPosY;
            }
        }
        if(keys['d']){
            const newPosX = posX + planeX * moveSpeed;
            const newPosY = posY + planeY * moveSpeed;
            
            if (map[Math.floor(posY)][Math.floor(newPosX)] === 0 ||
                map[Math.floor(posY)][Math.floor(newPosX)] === 2) {
                posX = newPosX;
            }
            if (map[Math.floor(newPosY)][Math.floor(posX)] === 0 ||
                map[Math.floor(newPosY)][Math.floor(posX)] === 2) {
                posY = newPosY;
            }
        }
    
        // Check if player reaches ammo pickups
        for (let i = ammoPickups.length - 1; i >= 0; i--) {
            const dx = ammoPickups[i].x - posX;
            const dy = ammoPickups[i].y - posY;
            if (Math.sqrt(dx*dx + dy*dy) < 0.5) {
                if (ammoPickups[i].isShotgun && !hasShotgun) {
                    hasShotgun = true;
                    playerWeapons.push('shotgun');
                    shotgunAmmo = 10;
                    currentWeapon = 'shotgun'; // Automatically equip shotgun
                    // Change music
                    bgMusic.pause();
                    ripAndTearMusic.currentTime = 0;
                    ripAndTearMusic.play().catch(error => console.log("Audio play failed:", error));
                } else {
                    if (currentWeapon === 'pistol' || !hasShotgun) {
                        playerAmmo = Math.min(maxAmmo, playerAmmo + 5);
                    } else {
                        shotgunAmmo = Math.min(maxShotgunAmmo, shotgunAmmo + 5);
                    }
                }
                ammoPickups.splice(i, 1);
                updateHUD();
            }
        }
    
        // Check if player reaches health pickups
        for (let i = healthPickups.length - 1; i >= 0; i--) {
            const dx = healthPickups[i].x - posX;
            const dy = healthPickups[i].y - posY;
            if (Math.sqrt(dx*dx + dy*dy) < 0.5) {
                playerHealth = Math.min(maxHealth, playerHealth + 5);
                healthPickups.splice(i, 1);
                updateHUD();
            }
        }
    
        // Check if player reached the exit
        if (map[Math.floor(posY)][Math.floor(posX)] === 2) {
            level++;
            generateLevel();
            updateHUD();
        }
    }
    
    window.addEventListener('keydown', (e) => {
        if (hasShotgun) {
            if (e.key === '1') {
                currentWeapon = 'pistol';
                updateHUD();
            } else if (e.key === '2') {
                currentWeapon = 'shotgun';
                updateHUD();
            }
        }
    });
    
    const brickPattern = context.createPattern(createBrickTexture(), 'repeat');
    const metalPattern = context.createPattern(createMetalTexture(), 'repeat');
    const exitPattern = context.createPattern(createExitTexture(), 'repeat');
    
    function createBrickTexture() {
        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = 64;
        textureCanvas.height = 64;
        const txtCtx = textureCanvas.getContext('2d');
        txtCtx.fillStyle = '#8B4513';
        txtCtx.fillRect(0, 0, 64, 64);
        txtCtx.fillStyle = '#654321';
        for(let y = 0; y < 64; y += 16) {
            let offset = (y % 32 === 0) ? 0 : 32;
            for(let x = offset; x < 64; x += 32) {
                txtCtx.fillRect(x, y, 28, 14);
            }
        }
        const imageData = txtCtx.getImageData(0, 0, 64, 64);
        const data = imageData.data;
        for(let i = 0; i < data.length; i += 4) {
            const noise = Math.random() * 20 - 10;
            data[i] = Math.max(0, Math.min(255, data[i] + noise));
            data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
            data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
        }
        txtCtx.putImageData(imageData, 0, 0);
        return textureCanvas;
    }
    
    function createMetalTexture() {
        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = 64;
        textureCanvas.height = 64;
        const txtCtx = textureCanvas.getContext('2d');
        txtCtx.fillStyle = '#707070';
        txtCtx.fillRect(0, 0, 64, 64);
        for(let i = 0; i < 20; i++) {
            txtCtx.strokeStyle = `rgba(100,100,100,${Math.random() * 0.5})`;
            txtCtx.beginPath();
            txtCtx.moveTo(Math.random() * 64, Math.random() * 64);
            txtCtx.lineTo(Math.random() * 64, Math.random() * 64);
            txtCtx.stroke();
        }
        const imageData = txtCtx.getImageData(0, 0, 64, 64);
        const data = imageData.data;
        for(let i = 0; i < data.length; i += 4) {
            const noise = Math.random() * 15 - 7.5;
            data[i] = Math.max(0, Math.min(255, data[i] + noise));
            data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
            data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
        }
        txtCtx.putImageData(imageData, 0, 0);
        return textureCanvas;
    }
    
    function createExitTexture() {
        const textureCanvas = document.createElement('canvas');
        textureCanvas.width = 64;
        textureCanvas.height = 64;
        const txtCtx = textureCanvas.getContext('2d');
        txtCtx.fillStyle = '#00FF00';
        txtCtx.fillRect(0, 0, 64, 64);
        txtCtx.fillStyle = '#007700';
        txtCtx.fillRect(8, 8, 48, 48);
        txtCtx.fillStyle = '#00FF00';
        txtCtx.fillRect(16, 16, 32, 32);
        return textureCanvas;
    }
    
    function drawGun() {
        const gunHeight = canvas.height * 0.5;
        const gunWidth = gunHeight * 0.8;
        const gunX = canvas.width / 2 - gunWidth / 2;
        const gunY = canvas.height - gunHeight + (isShooting ? Math.sin(shootAnimationTime) * 20 : 0);
    
        if (currentWeapon === 'pistol') {
            // Existing pistol drawing code
            context.fillStyle = 'rgba(0,0,0,0.3)';
            context.fillRect(gunX + gunWidth * 0.32, gunY + gunHeight * 0.32, gunWidth * 0.4, gunHeight * 0.7);
    
            const gradient = context.createLinearGradient(gunX, gunY, gunX + gunWidth, gunY);
            gradient.addColorStop(0, '#555');
            gradient.addColorStop(0.4, '#777');
            gradient.addColorStop(0.6, '#666');
            gradient.addColorStop(1, '#444');
    
            context.fillStyle = gradient;
            context.fillRect(gunX + gunWidth * 0.3, gunY + gunHeight * 0.3, gunWidth * 0.4, gunHeight * 0.7);
    
            const barrelGradient = context.createLinearGradient(gunX, gunY, gunX, gunY + gunHeight * 0.3);
            barrelGradient.addColorStop(0, '#333');
            barrelGradient.addColorStop(0.5, '#555');
            barrelGradient.addColorStop(1, '#222');
            context.fillStyle = barrelGradient;
            context.fillRect(gunX + gunWidth * 0.35, gunY + gunHeight * 0.1, gunWidth * 0.3, gunHeight * 0.3);
    
            context.fillStyle = '#888';
            context.fillRect(gunX + gunWidth * 0.31, gunY + gunHeight * 0.31, gunWidth * 0.38, gunHeight * 0.02);
        } else {
            // Shotgun drawing code
            // Draw shadow
            context.fillStyle = 'rgba(0,0,0,0.3)';
            context.fillRect(gunX + gunWidth * 0.25, gunY + gunHeight * 0.32, gunWidth * 0.5, gunHeight * 0.7);
    
            // Main body
            const gradient = context.createLinearGradient(gunX, gunY, gunX + gunWidth, gunY);
            gradient.addColorStop(0, '#654321');
            gradient.addColorStop(0.4, '#8B4513');
            gradient.addColorStop(0.6, '#8B4513');
            gradient.addColorStop(1, '#654321');
    
            context.fillStyle = gradient;
            context.fillRect(gunX + gunWidth * 0.25, gunY + gunHeight * 0.3, gunWidth * 0.5, gunHeight * 0.7);
    
            // Double barrels
            const barrelGradient = context.createLinearGradient(gunX, gunY, gunX, gunY + gunHeight * 0.4);
            barrelGradient.addColorStop(0, '#333');
            barrelGradient.addColorStop(0.5, '#555');
            barrelGradient.addColorStop(1, '#222');
            
            context.fillStyle = barrelGradient;
            context.fillRect(gunX + gunWidth * 0.3, gunY + gunHeight * 0.1, gunWidth * 0.2, gunHeight * 0.4);
            context.fillRect(gunX + gunWidth * 0.5, gunY + gunHeight * 0.1, gunWidth * 0.2, gunHeight * 0.4);
    
            // Pump action
            context.fillStyle = '#8B4513';
            context.fillRect(gunX + gunWidth * 0.35, gunY + gunHeight * 0.5, gunWidth * 0.3, gunHeight * 0.1);
    
            if (isReloading) {
                // Reload animation
                context.save();
                context.translate(gunX + gunWidth * 0.5, gunY + gunHeight * 0.3);
                context.rotate(Math.PI * reloadProgress / 50);
                context.translate(-(gunX + gunWidth * 0.5), -(gunY + gunHeight * 0.3));
                context.fillStyle = '#4a3000';
                context.fillRect(gunX + gunWidth * 0.48, gunY + gunHeight * 0.28, gunWidth * 0.04, gunHeight * 0.1);
                context.restore();
            }
        }
    
        if (isShooting) {
            const flash = context.createRadialGradient(
                gunX + gunWidth * 0.5, gunY + gunHeight * 0.1, 5,
                gunX + gunWidth * 0.5, gunY + gunHeight * 0.1, currentWeapon === 'shotgun' ? 40 : 25
            );
            flash.addColorStop(0, 'rgba(255,255,200,1)');
            flash.addColorStop(0.1, 'rgba(255,200,0,0.8)');
            flash.addColorStop(0.4, 'rgba(255,100,0,0.4)');
            flash.addColorStop(1, 'rgba(255,50,0,0)');
    
            context.fillStyle = flash;
            context.beginPath();
            context.arc(gunX + gunWidth * 0.5, gunY + gunHeight * 0.1, currentWeapon === 'shotgun' ? 40 : 25, 0, Math.PI * 2);
            context.fill();
        }
    }
    
    function drawCrosshair() {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const size = 20;
    
        context.strokeStyle = '#f00';
        context.lineWidth = 2;
    
        context.beginPath();
        context.moveTo(centerX - size, centerY);
        context.lineTo(centerX + size, centerY);
        context.moveTo(centerX, centerY - size);
        context.lineTo(centerX, centerY + size);
        context.stroke();
    }
    
    function renderScene(){
        context.clearRect(0,0,canvas.width,canvas.height);
        context.fillStyle='#4444ff';
        context.fillRect(0,0,canvas.width,canvas.height/2);
        context.fillStyle='#444444';
        context.fillRect(0,canvas.height/2,canvas.width,canvas.height/2);
    
        for(let x=0;x<canvas.width;x++){
            const cameraX=2*x/canvas.width-1;
            const rayDirX=dirX+planeX*cameraX;
            const rayDirY=dirY+planeY*cameraX;
            let mapX=Math.floor(posX);
            let mapY=Math.floor(posY);
            let sideDistX;
            let sideDistY;
            const deltaDistX=Math.abs(1/rayDirX);
            const deltaDistY=Math.abs(1/rayDirY);
            let perpWallDist;
            let stepX;
            let stepY;
            let hit=0;
            let side;
    
            if(rayDirX<0){
                stepX=-1;
                sideDistX=(posX-mapX)*deltaDistX;
            }else{
                stepX=1;
                sideDistX=(mapX+1.0-posX)*deltaDistX;
            }
            if(rayDirY<0){
                stepY=-1;
                sideDistY=(posY-mapY)*deltaDistY;
            }else{
                stepY=1;
                sideDistY=(mapY+1.0-posY)*deltaDistY;
            }
    
            while(hit===0){
                if(sideDistX<sideDistY){
                    sideDistX+=deltaDistX;
                    mapX+=stepX;
                    side=0;
                }else{
                    sideDistY+=deltaDistY;
                    mapY+=stepY;
                    side=1;
                }
                if(map[mapY][mapX]>0)hit=1;
            }
    
            if(side===0)perpWallDist=(mapX-posX+(1-stepX)/2)/rayDirX;
            else perpWallDist=(mapY-posY+(1-stepY)/2)/rayDirY;
    
            const lineHeight=(canvas.height/perpWallDist);
            let drawStart=-lineHeight/2+canvas.height/2;
            if(drawStart<0)drawStart=0;
            let drawEnd=lineHeight/2+canvas.height/2;
            if(drawEnd>=canvas.height)drawEnd=canvas.height-1;
    
            let texture;
            if(map[mapY][mapX] === 1) {
                texture = side===1 ? metalPattern : brickPattern;
            } else if(map[mapY][mapX] === 2) {
                texture = exitPattern;
            }
    
            context.strokeStyle=texture;
            context.lineWidth=2;
            context.beginPath();
            context.moveTo(x,drawStart);
            context.lineTo(x,drawEnd);
            context.stroke();
        }
    
        drawMonsters();
        drawEnemyProjectiles();
        drawPlayerProjectiles();
        drawPickups();
        drawGun();
        drawCrosshair();
    
        if(isShooting){
            shootAnimationTime--;
            if(shootAnimationTime<=0){
                isShooting=false;
            }
        }
    }
    
    function gameLoop(){
        if (playerHealth <= 0) {
            const timeAlive = Math.floor((Date.now() - startTime) / 1000); // Time in seconds
            showLeaderboard(score, timeAlive);
            return; // Stop game loop until player restarts
        }
        movePlayer();
        updateMonsters();
        renderScene();
        
        // Reload animation update
        if (isReloading) {
            reloadProgress++;
            if (reloadProgress >= 50) { // 50 frames for reload animation
                isReloading = false;
                reloadProgress = 0;
            }
        }
        
        requestAnimationFrame(gameLoop);
    }
    
    async function showLeaderboard(finalScore, timeAlive) {
        // Create dark overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            overflow-y: auto;
            cursor: default;
        `;
        
        // Create leaderboard container
        const leaderboardContainer = document.createElement('div');
        leaderboardContainer.style.cssText = `
            background: #222;
            padding: 20px;
            border: 2px solid #f00;
            border-radius: 10px;
            min-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #f00 #222;
        `;
    
        // Initialize WebsimSocket and save score
        const room = new WebsimSocket();
        
        // Create content while scores load
        leaderboardContainer.innerHTML = `
            <h2 style="color: #f00; text-align: center;">GAME OVER</h2>
            <p style="text-align: center;">Your Score: ${finalScore}<br>Time Alive: ${timeAlive}s<br>Level Reached: ${level}</p>
            <h3 style="color: #f00; text-align: center;">TOP SCORES</h3>
            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 10px;">
                <button id="sortScore" class="sortBtn active" style="
                    padding: 5px 10px;
                    background: #f00;
                    color: #fff;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                ">Score</button>
                <button id="sortPerSecond" class="sortBtn" style="
                    padding: 5px 10px;
                    background: #400;
                    color: #fff;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                ">Score/s</button>
                <button id="sortTime" class="sortBtn" style="
                    padding: 5px 10px;
                    background: #400;
                    color: #fff;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                ">Time</button>
                <button id="sortLevel" class="sortBtn" style="
                    padding: 5px 10px;
                    background: #400;
                    color: #fff;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                ">Level</button>
            </div>
            <div id="scoresContainer" style="
                max-height: 200px; 
                overflow-y: auto;
                overflow-x: hidden;
                scrollbar-width: thin;
                scrollbar-color: #f00 #222;
                padding-right: 5px;
            ">
                <p style="text-align: center">Loading scores...</p>
            </div>
            <button id="restartButton" style="
                margin-top: 20px;
                padding: 10px 20px;
                background: #f00;
                color: #fff;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-family: 'Courier New', monospace;
                font-size: 16px;
            ">RESTART</button>
        `;
    
        overlay.appendChild(leaderboardContainer);
        document.body.appendChild(overlay);
    
        // Add custom scrollbar styling for webkit browsers
        const styleSheet = document.createElement('style');
        styleSheet.textContent = `
            ::-webkit-scrollbar {
                width: 8px;
            }
            
            ::-webkit-scrollbar-track {
                background: #222;
                border-radius: 4px;
            }
            
            ::-webkit-scrollbar-thumb {
                background: #f00;
                border-radius: 4px;
            }
            
            ::-webkit-scrollbar-thumb:hover {
                background: #ff3333;
            }
        `;
        document.head.appendChild(styleSheet);
    
        // Save score and update leaderboard
        (async function() {
            // Save the score first
            await room.collection('doom_scores').create({
                score: finalScore,
                timeAlive: timeAlive,
                level: level
            });
    
            // Then get and display all scores
            room.collection('doom_scores').subscribe(function(scores) {
                updateScoreDisplay(scores);
            });
        })();
    
        // Add event listeners for sort buttons
        document.querySelectorAll('.sortBtn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                // Remove active class from all buttons
                document.querySelectorAll('.sortBtn').forEach(b => {
                    b.classList.remove('active');
                    b.style.background = '#400';
                });
                
                // Add active class to clicked button
                e.target.classList.add('active');
                e.target.style.background = '#f00';
                
                // Update sort type
                if (e.target.id === 'sortScore') currentSort = 'score';
                if (e.target.id === 'sortPerSecond') currentSort = 'perSecond';
                if (e.target.id === 'sortTime') currentSort = 'time';
                if (e.target.id === 'sortLevel') currentSort = 'level';
                
                // Update display with new sort
                room.collection('doom_scores').subscribe(scores => updateScoreDisplay(scores));
            });
        });
    
        let currentSort = 'score'; // Default sort
    
        function updateScoreDisplay(scores) {
            const scoresContainer = document.getElementById('scoresContainer');
            if (!scoresContainer) return;
    
            let sortedScores = [...scores];
            
            switch(currentSort) {
                case 'score':
                    sortedScores.sort((a, b) => b.score - a.score);
                    break;
                case 'perSecond':
                    sortedScores.sort((a, b) => (b.score / b.timeAlive) - (a.score / a.timeAlive));
                    break;
                case 'time':
                    sortedScores.sort((a, b) => a.timeAlive - b.timeAlive);
                    break;
                case 'level':
                    sortedScores.sort((a, b) => b.level - a.level);
                    break;
            }
    
            sortedScores = sortedScores.slice(0, 100);
    
            let content = `
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="color: #f00;">
                        <th style="padding: 5px; text-align: left;">Player</th>
                        <th style="padding: 5px;">Score</th>
                        <th style="padding: 5px;">Score/s</th>
                        <th style="padding: 5px;">Time</th>
                        <th style="padding: 5px;">Level</th>
                    </tr>
            `;
    
            sortedScores.forEach(entry => {
                const scorePerSecond = (entry.score / entry.timeAlive).toFixed(2);
                content += `
                    <tr style="border-top: 1px solid #444;">
                        <td style="padding: 5px;">${entry.username}</td>
                        <td style="padding: 5px; text-align: center;">${entry.score}</td>
                        <td style="padding: 5px; text-align: center;">${scorePerSecond}</td>
                        <td style="padding: 5px; text-align: center;">${entry.timeAlive}s</td>
                        <td style="padding: 5px; text-align: center;">${entry.level}</td>
                    </tr>
                `;
            });
    
            content += `</table>`;
            scoresContainer.innerHTML = content;
        }
    
        // Add restart functionality
        document.getElementById('restartButton').addEventListener('click', () => {
            document.body.removeChild(overlay);
            // Reset game state
            playerHealth = 100;
            playerAmmo = 50;
            level = 1;
            score = 0;
            startTime = Date.now();
            hasShotgun = false;  // Ensure shotgun is reset
            shotgunAmmo = 0;     // Reset shotgun ammo
            playerWeapons = ['pistol'];  // Reset weapons to just pistol
            currentWeapon = 'pistol';    // Set current weapon back to pistol
            // Stop Rip & Tear music if it's playing
            ripAndTearMusic.pause();
            ripAndTearMusic.currentTime = 0;
            // Start original background music
            bgMusic.currentTime = 0;
            bgMusic.play().catch(error => console.log("Audio play failed:", error));
            generateLevel();
            updateHUD();
            gameLoop();
        });
    }
    
    function generateLevel() {
        // Generate a new map
        const mapWidth = 16;
        const mapHeight = 16;
        map = [];
        
        // Reset pickups arrays
        ammoPickups = [];
        healthPickups = [];
    
        // First, create all walls
        for (let y = 0; y < mapHeight; y++) {
            map[y] = [];
            for (let x = 0; x < mapWidth; x++) {
                // Borders are walls
                if (x === 0 || y === 0 || x === mapWidth - 1 || y === mapHeight - 1) {
                    map[y][x] = 1;
                } else {
                    map[y][x] = 0;
                }
            }
        }
    
        // Clear player's starting area
        const startX = 1;
        const startY = 1;
        const exitX = mapWidth - 2;
        const exitY = mapHeight - 2;
    
        // Create a guaranteed path from start to exit
        let currentX = startX;
        let currentY = startY;
        
        // First move horizontally
        while (currentX < exitX) {
            map[currentY][currentX] = 0;
            currentX++;
        }
        
        // Then move vertically
        while (currentY < exitY) {
            map[currentY][currentX] = 0;
            currentY++;
        }
    
        // Now add random walls, but not on the path
        for (let y = 1; y < mapHeight - 1; y++) {
            for (let x = 1; x < mapWidth - 1; x++) {
                // Skip the guaranteed path and starting area
                if ((x === startX && y === startY) || 
                    (x === exitX && y === exitY) ||
                    (y === startY && x <= exitX) ||
                    (x === exitX && y <= exitY)) {
                    continue;
                }
                // Randomly place walls
                if (Math.random() < 0.2) {
                    map[y][x] = 1;
                }
            }
        }
    
        // Place player at starting position
        posX = 1.5;
        posY = 1.5;
        dirX = 1;
        dirY = 0;
        planeX = 0;
        planeY = 0.66;
    
        // Place the exit door
        map[exitY][exitX] = 2;
    
        // Clear monsters array
        monsters = [];
        
        // Add monsters
        for (let i = 0; i < level + 3; i++) {
            let monsterX, monsterY;
            do {
                monsterX = Math.floor(Math.random() * (mapWidth - 2)) + 1;
                monsterY = Math.floor(Math.random() * (mapHeight - 2)) + 1;
            } while (map[monsterY][monsterX] !== 0 || (Math.abs(monsterX - posX) + Math.abs(monsterY - posY) < 4));
            
            const rand = Math.random();
            let monster;
            if (rand < 0.5) {
                monster = new Monster(monsterX + 0.5, monsterY + 0.5);
            } else if (rand < 0.8) {
                monster = new FastMonster(monsterX + 0.5, monsterY + 0.5);
            } else {
                monster = new StrongMonster(monsterX + 0.5, monsterY + 0.5);
            }
            monsters.push(monster);
        }
    
        // Generate pickups
        const numAmmoPickups = Math.floor(Math.random() * 3) + 2; // 2-4 ammo pickups
        const numHealthPickups = Math.floor(Math.random() * 3) + 2; // 2-4 health pickups
        
        // Always try to spawn shotgun if player doesn't have it
        // Remove old condition and force a shotgun spawn attempt
        if (!hasShotgun) {
            let x, y;
            do {
                x = Math.floor(Math.random() * (mapWidth - 2)) + 1;
                y = Math.floor(Math.random() * (mapHeight - 2)) + 1;
            } while (map[y][x] !== 0 || (Math.abs(x - posX) + Math.abs(y - posY) < 4));
            ammoPickups.push({x: x + 0.5, y: y + 0.5, isShotgun: true});
        }
    
        // Generate ammo pickups
        for (let i = 0; i < numAmmoPickups; i++) {
            let x, y;
            do {
                x = Math.floor(Math.random() * (mapWidth - 2)) + 1;
                y = Math.floor(Math.random() * (mapHeight - 2)) + 1;
            } while (map[y][x] !== 0 || (Math.abs(x - posX) + Math.abs(y - posY) < 4));
            ammoPickups.push({x: x + 0.5, y: y + 0.5, isShotgun: false});
        }
    
        // Generate health pickups
        for (let i = 0; i < numHealthPickups; i++) {
            let x, y;
            do {
                x = Math.floor(Math.random() * (mapWidth - 2)) + 1;
                y = Math.floor(Math.random() * (mapHeight - 2)) + 1;
            } while (map[y][x] !== 0 || (Math.abs(x - posX) + Math.abs(y - posY) < 4));
            healthPickups.push({x: x + 0.5, y: y + 0.5});
        }
        
        updateHUD();
    }
    
    generateLevel();
    updateHUD();
    gameLoop();
    bgMusic.volume = 0.5;
    bgMusic.play().catch(error => {
        console.log("Trying to play background music again in response to user interaction");
        document.addEventListener('click', () => {
            bgMusic.play().catch(error => console.log("Audio play failed:", error));
        }, { once: true });
    });
    })();</script></body></html>